
#coding:utf-8
import time, datetime, traceback, sys
from xtquant import xtdata
from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
from xtquant.xttype import StockAccount
from xtquant import xtconstant

from constants.account_id import account_id
from constants.qmt_path import qmt_path

from utils.xtUtil import to_full_code
from utils.algorism import *
from utils.lidu import lidu

def simpleStart():
    # if neet to buy or sell
    to_trade = False

    # 创建资金账号为 xxxxxx 的证券账号对象
    acct = StockAccount(account_id, 'STOCK')  # STOCK or CREDIT
    xt_trader = init_xt_trader(acct)
    # 关注列表
    stock_list = {"002273":{"name":"水晶光电", "action_type": "buy", "per_amo": 60000, "max_amo": 130000},
                   "300843":{"name":"胜蓝股份" , "action_type": "sell","per_percent": 100, "per_amo": 60000, "max_amo": 130000},
                    "300176":{"name":"派生科技" , "action_type": "sell","per_percent": 100, "per_amo": 60000, "max_amo": 130000}}
    # 取关列表
    # 使用分钟订阅数据计算信号, 后期改为订阅实时数据
    period = '1m'
    min_data = {}
    def on_data(datas):
        nonlocal min_data
        for stock_code, data in datas.items():
            # 数据存起来
            min_data[stock_code] = pd.DataFrame(data)
        # 计算指标
        for stockCode, data in stock_list.items():
            kdata_signals = lidu(min_data[to_full_code(stockCode)])
            
            if kdata_signals['买入信号'].iloc[-1] > 0:
                if to_trade:
                    # such as buy 100 stocks of 600xxx at 10
                    stk = to_full_code(stockCode)
                    vol = 6099 / 100 / data['close'][-1]
                    price = data['close'][-1]

                    async_seq = xt_trader.order_stock_async(
                        acct,
                        stk,
                        xtconstant.STOCK_BUY,
                        vol,
                        xtconstant.FIX_PRICE,
                        price,
                        'strategy_name_sell',
                        stk
                        )
                    print('async_seq', async_seq)
                else:
                    print("买入信号触发, 不实际操作")
                    
                if kdata_signals['卖出信号'].iloc[-1] > 0:
                    if to_trade:
                        # such as buy 100 stocks of 600xxx at 10
                        stk = to_full_code(stockCode)
                        vol = data['openInt'][-1]
                        price = data['close'][-1]

                        async_seq = xt_trader.order_stock_async(
                            acct,
                            stk,
                            xtconstant.STOCK_SELL,
                            vol,
                            xtconstant.FIX_PRICE,
                            price,
                            'strategy_name_sell',
                            stk
                            )
                        print('async_seq', async_seq)
                    else:
                        print("卖出信号触发, 不实际操作")
            
            
    # 单股订阅分钟K
    # for stockCode, data in buying_list.items():
    #     full_stock_code = to_full_code(stockCode)
    #     xtdata.subscribe_quote(full_stock_code, period=period,count= 240, callback= on_data)
    
    # for stockCode, data in selling_list.items():
    #     xtdata.subscribe_quote(to_full_code(stockCode), period=period,  end_time='', count= 240, callback= on_data)
    #     #xtdata.subscribe_quote(to_full_code(stockCode), period=period, start_time='', end_time='', count=0, callback= on_data)
    for 
    
    init_kData = xtdata.get_market_data(field_list=[], stock_list=[stock_list.keys], period='1d', start_time='', end_time='', count=-1, dividend_type='none', fill_data=True)

    
    # 订阅全推行情
    book_tickData = xtdata.subscribe_whole_quote(code_list= [stock_list.keys], callback=on_data)
    
    
    xtdata.run()
    
    
def init_xt_trader(account_id):
    # miniqmt_path = r'D:\QMT交易端模拟\userdata_mini'
    session_id = int(time.time())  # different strategy has different session_id
    xt_trader = XtQuantTrader(qmt_path, session_id)

    callback = MyXtQuantTraderCallback()
    xt_trader.register_callback(callback)

    # 启动交易线程
    xt_trader.start()

    # 建立交易连接，返回0表示连接成功
    print('connect, 0 means connected, -1 failed.', xt_trader.connect())

    # 对交易回调进行订阅，订阅后可以收到交易主推，返回0表示订阅成功
    print('trade call_back register, 0 means registered, -1 failed:', xt_trader.subscribe(account_id))

    return xt_trader

class MyXtQuantTraderCallback(XtQuantTraderCallback):
    def on_disconnected(self):
        """
        连接断开
        :return:
        """
        print(datetime.datetime.now(),'连接断开回调')

    def on_stock_order(self, order):
        """
        委托回报推送
        :param order: XtOrder对象
        :return:
        """
        print(datetime.datetime.now(), '委托回调', order.order_remark)


    def on_stock_trade(self, trade):
        """
        成交变动推送
        :param trade: XtTrade对象
        :return:
        """
        print(datetime.datetime.now(), '成交回调', trade.order_remark)


    def on_order_error(self, order_error):
        """
        委托失败推送
        :param order_error:XtOrderError 对象
        :return:
        """
        # print("on order_error callback")
        # print(order_error.order_id, order_error.error_id, order_error.error_msg)
        print(f"委托报错回调 {order_error.order_remark} {order_error.error_msg}")

    def on_cancel_error(self, cancel_error):
        """
        撤单失败推送
        :param cancel_error: XtCancelError 对象
        :return:
        """
        print(datetime.datetime.now(), sys._getframe().f_code.co_name)

    def on_order_stock_async_response(self, response):
        """
        异步下单回报推送
        :param response: XtOrderResponse 对象
        :return:
        """
        print(f"异步委托回调 {response.order_remark}")

    def on_cancel_order_stock_async_response(self, response):
        """
        :param response: XtCancelOrderResponse 对象
        :return:
        """
        print(datetime.datetime.now(), sys._getframe().f_code.co_name)

    def on_account_status(self, status):
        """
        :param response: XtAccountStatus 对象
        :return:
        """
        print(datetime.datetime.now(), sys._getframe().f_code.co_name)

